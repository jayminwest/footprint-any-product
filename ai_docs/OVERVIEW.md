# Project Overview: Data Flow and Agent Responsibilities

This document provides a high-level overview of the Footprint-Any-Product system, detailing the data flow from the frontend to the backend agents and back, and outlining the responsibilities of each AI agent within the LangGraph workflow.

## 1. Overall Data Flow

The system follows a client-server architecture with real-time communication enabled by WebSockets.

```
Frontend (Next.js) <── WebSocket ──> Backend (FastAPI) <── LangGraph ──> Agents (LLMs + Tools)
```

1.  **Frontend (Product Input):** The user enters product details (Brand, Category, Description) into the `ProductInput.tsx` component on the main page (`frontend/src/app/page.tsx`).
2.  **Frontend (Initiate Analysis):** When the user submits the form, the `page.tsx` component updates its state, triggering the `FootprintAnalysis.tsx` component.
3.  **Frontend (WebSocket Connection):** `FootprintAnalysis.tsx` establishes a WebSocket connection to the backend `/ws` endpoint (`ws://localhost:3005/ws`).
4.  **Backend (Receive Input):** The `main.py` FastAPI application accepts the WebSocket connection and receives the product details as a JSON payload.
5.  **Backend (LangGraph Execution):** Upon receiving the input, `main.py` initializes and starts the LangGraph workflow (`setup_graph()`). The product details are used to create the initial `FootprintState`.
6.  **LangGraph (Agent Processing):** The workflow executes the defined sequence of agent nodes. Each agent reads from and writes to the shared `FootprintState`. Agents use tools (like `emissions_factor_finder_tool` and `calculator`) to gather data and perform calculations.
7.  **Backend (Stream Updates):** As the LangGraph workflow progresses and the `FootprintState` is updated by the agents, LangGraph streams these changes (`updates` and `values`) back to the `main.py` application.
8.  **Backend (Format Messages):** `main.py` processes the streamed LangGraph updates, extracts relevant information (agent thoughts, tool calls, observations, phase summaries, carbon values), and formats them into standardized text messages (e.g., `Agent(materials): ...`, `PhaseCarbon(manufacturing): ...`, `FinalSummary: ...`).
9.  **Backend (Send via WebSocket):** These standardized messages are sent in real-time over the active WebSocket connection back to the frontend.
10. **Frontend (Receive and Parse):** `FootprintAnalysis.tsx` receives the streaming messages from the WebSocket. It parses the message format to identify the message type and the associated agent or phase.
11. **Frontend (Update State):** Based on the parsed messages, `FootprintAnalysis.tsx` updates its internal state, specifically the `agents` state object, which mirrors the structure of the backend's phase data.
12. **Frontend (Render UI):** The `FootprintAnalysis.tsx` component renders the analysis results dynamically using `AgentSection.tsx` components. Each `AgentSection` displays the messages, summary, and carbon footprint for a specific phase as the data arrives.
13. **Frontend (Completion):** When the backend sends the `AnalysisComplete` message, `FootprintAnalysis.tsx` updates its state to indicate completion, potentially triggering the `onStreamingComplete` callback in `page.tsx` to update the UI (e.g., re-enable the input form).

## 2. Shared State (`FootprintState`)

Defined in `state.py`, `FootprintState` is a `TypedDict` that acts as the central memory for the LangGraph workflow. It holds all data relevant to the analysis, including:

*   Initial product details (`brand`, `category`, `description`).
*   A cumulative list of all messages generated by the workflow (`messages`).
*   Specific nested dictionaries for the output of each lifecycle phase (`planner`, `materials`, `manufacturing`, `packaging`, `transportation`, `use`, `eol`). Each of these phase dictionaries contains `messages`, `summary`, and `carbon` fields.

All agent nodes receive the current `FootprintState` as input and return a dictionary of updates that are merged back into the shared state by LangGraph.

## 3. LangGraph Workflow Structure

The workflow in `main.py` is a directed graph (`StateGraph`) orchestrating the agents:

*   **Start:** The graph begins.
*   **`planner_phase`:** The first node executed. It likely takes the initial product details and perhaps refines the plan or extracts key information needed by subsequent agents. It updates the `"planner"` key in the state.
*   **Parallel Phase Agents:** After the `planner_phase` completes, the graph transitions to multiple nodes simultaneously: `materials_phase`, `manufacturing_phase`, `packaging_phase`, `transportation_phase`, `use_phase`, and `eol_phase`. These agents run in parallel, each focusing on a specific lifecycle stage. They read the shared state (which now includes the planner's output) and write their results to their respective keys (`"materials"`, `"manufacturing"`, etc.) in the state.
*   **`summarizer`:** This node is executed only after *all* the parallel phase agents have completed. It receives the final state containing the results from all phases. Its responsibility is to aggregate the carbon footprints from each phase and calculate the total, adding a final summary to the state (likely via the `"messages"` key or a dedicated key).
*   **End:** The graph finishes execution.

## 4. Agent Responsibilities

Each agent is a specialized AI model (using `langgraph.prebuilt.create_react_agent`) configured with specific tools and a system prompt tailored to its domain. They operate within their respective nodes in the LangGraph workflow.

*   **`planner_phase` (agents/planner.py):** (Based on graph structure, not code provided) Likely responsible for initial processing of user input, potentially breaking down the task or extracting key details for other agents.
*   **`materials_phase` (agents/materials.py):** Estimates the carbon footprint associated with the raw materials used in the product. It considers different material types, estimates weights, researches emissions factors, and calculates impact, writing results to `state["materials"]`.
*   **`manufacturing_phase` (agents/manufacturing.py):** Estimates the carbon footprint of the manufacturing processes. It considers energy use, process emissions, etc., writing results to `state["manufacturing"]`.
*   **`packaging_phase` (agents/packaging.py):** Estimates the carbon footprint of the product's packaging. It considers packaging materials and processes, writing results to `state["packaging"]`.
*   **`transportation_phase` (agents/transportation.py):** Estimates the carbon footprint from transporting the product throughout its lifecycle (from manufacturing to consumer, potentially end-of-life transport). It focuses on modes of transport and distances (though location tools are noted as TODO), writing results to `state["transportation"]`.
*   **`use_phase` (agents/use.py):** Estimates the carbon footprint associated with the product's usage phase (e.g., energy consumption for electronics, washing for textiles). It writes results to `state["use"]`.
*   **`eol_phase` (agents/eol.py):** Estimates the carbon footprint of the product's end-of-life phase (e.g., disposal, recycling, landfill). It writes results to `state["eol"]`.
*   **`summarizer` (main.py):** Aggregates the carbon footprints calculated by all the phase agents to produce a final total carbon footprint and overall summary.

Each agent is configured with `emissions_factor_finder_tool` and `calculator` to assist in their analysis and calculations.

This structure allows for modular development of each lifecycle phase's analysis while leveraging a shared state and workflow orchestration provided by LangGraph. The WebSocket connection enables the backend to stream these intermediate and final results to the frontend in real-time.
